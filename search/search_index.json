{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Symbolicator is a standalone service that resolves function names, file location and source context in native stack traces. It can process Minidumps and Apple Crash Reports. Additionally, Symbolicator can act as a proxy to symbol servers supporting multiple formats, such as Microsoft's symbol server or Breakpad symbol repositories. Usage Start the server with: $ symbolicator run -c config.yml The configuration file can be omitted. Symbolicator will run with default settings in this case. Configuration Write this to a file ( config.yml ): cache_dir : \"/tmp/symbolicator\" bind : \"0.0.0.0:3021\" logging : level : \"info\" format : \"pretty\" enable_backtraces : true metrics : statsd : \"127.0.0.1:8125\" prefix : \"symbolicator\" cache_dir : Path to a directory to cache downloaded files and symbolication caches. Defaults to /data inside Docker which is already defined as a persistent volume, and null otherwise, which disables caching. It is strictly recommended to configure caches in production! bind : Host and port for HTTP interface. bind_https : Host and port for optional HTTPS interface. Notes: - HTTPS support is a Cargo feature, and needs to be enabled during building: shell cargo build --features https <other build options> - Additionally for HTTPS support, paths to TLS certificate and key files need to be specified in the configuration file: - server_config : web server configuration needed for serving over HTTPS. - https : HTTPS configuration. - certificate_path : Path to a TLS certificate file in PEM format. - key_path : Path to a TLS key file in PEM format. - logging : Command line logging behavior. - level : Log level, defaults to info . Can be one of off , error , warn , info , debug , or trace . - format : The format with which to print logs. Defaults to auto . Can be one of: json , simplified , pretty , or auto (pretty on console, simplified on tty). - enable_backtraces : Whether backtraces for errors should be computed. This causes a slight performance hit but improves debuggability. Defaults to true . - metrics : Configure a statsd server to send metrics to. - statsd : The host and port to send metrics to. Defaults to STATSD_SERVER environment variable or in case it is not defined, then it defaults to null , which disables metric submission. - prefix : A prefix for every metric, defaults to symbolicator . - hostname_tag : If set, report the current hostname under the given tag name for all metrics. - environment_tag : If set, report the current environment under the given tag name for all metrics. - sentry_dsn : DSN to a Sentry project for internal error reporting. Defaults to null , which disables reporting to Sentry. - sources : An optional list of preconfigured sources. If these are configured they will be used as default sources for symbolication requests and they will be proxied by the symbol proxy if enabled. The format for the sources here matches the sources in the HTTP API. - symstore_proxy : Enables or disables the symstore proxy mode. Creates an endpoint to download raw symbols from configured sources Symbolicator as if it were a symstore (Microsoft Symbol Server) compatible server. Defaults to true . - connect_to_reserved_ips : Allow reserved IP addresses for requests to sources. See Security . Defaults to false . - max_concurrent_requests : The maximum number of requests symbolicator will process concurrently. Further requests will result in a 503 status code. Set it to null to turn off the limit. Defaults to 120. All time units for the following configuration settings can be either a time expression like 1s . Units can be s , seconds , m , minutes , h , hours , d , days , w , weeks , M , months , y , years . max_download_timeout : The timeout for downloading debug files. connect_timeout : The timeout for establishing a connection to a symbol server to download debug files. streaming_timeout : The timeout for streaming the contents of a debug file. caches : Fine-tune cache expiry. Time units for caches may also be null to disable cache expiration. downloaded : Fine-tune caches for downloaded files. max_unused_for : Maximum duration to keep a file since last use of it. retry_misses_after : Duration to wait before re-trying to download a file which was not found. retry_malformed_after : Duration to wait before re-trying to download a file which was malformed. max_lazy_redownloads : Symbolicator will fall back to a compatible but out-of-date cache version if available, and start computing the up-to-date version in the background. This option sets the maximum number of such lazy downloads that symbolicator will do concurrently. Defaults to 50. derived : Fine-tune caches for files which are derived from downloaded files. These files are usually versions of the downloaded files optimised for fast lookups. max_unused_for : Maximum duration to keep a file since last use of it. retry_misses_after : Duration to wait before re-trying to download a file which was not found. retry_malformed_after : Duration to wait before re-trying to download a file which was malformed. max_lazy_recomputations : Symbolicator will fall back to a compatible but out-of-date cache version if available, and start computing the up-to-date version in the background. This option sets the maximum number of such lazy computations that symbolicator will do concurrently. Defaults to 20. diagnostics : This configures the duration diagnostics data will be stored in cache. E.g. minidumps which failed to be processed correctly will be stored in this cache. retention : Duration a file will be kept in this cache. Security By default, Symbolicator does not try to download debug files from reserved IP ranges . This ensures that no unintended connections are made to internal systems when source configuration is passed in from an untrusted source. To allow internal connections, set connect_to_reserved_ips to true . An exception from this rule is the \"sentry\" source type. Sentry is expected to run within the same network as Symbolicator, which is why it is exempt by default.","title":"Introduction"},{"location":"#usage","text":"Start the server with: $ symbolicator run -c config.yml The configuration file can be omitted. Symbolicator will run with default settings in this case.","title":"Usage"},{"location":"#configuration","text":"Write this to a file ( config.yml ): cache_dir : \"/tmp/symbolicator\" bind : \"0.0.0.0:3021\" logging : level : \"info\" format : \"pretty\" enable_backtraces : true metrics : statsd : \"127.0.0.1:8125\" prefix : \"symbolicator\" cache_dir : Path to a directory to cache downloaded files and symbolication caches. Defaults to /data inside Docker which is already defined as a persistent volume, and null otherwise, which disables caching. It is strictly recommended to configure caches in production! bind : Host and port for HTTP interface. bind_https : Host and port for optional HTTPS interface. Notes: - HTTPS support is a Cargo feature, and needs to be enabled during building: shell cargo build --features https <other build options> - Additionally for HTTPS support, paths to TLS certificate and key files need to be specified in the configuration file: - server_config : web server configuration needed for serving over HTTPS. - https : HTTPS configuration. - certificate_path : Path to a TLS certificate file in PEM format. - key_path : Path to a TLS key file in PEM format. - logging : Command line logging behavior. - level : Log level, defaults to info . Can be one of off , error , warn , info , debug , or trace . - format : The format with which to print logs. Defaults to auto . Can be one of: json , simplified , pretty , or auto (pretty on console, simplified on tty). - enable_backtraces : Whether backtraces for errors should be computed. This causes a slight performance hit but improves debuggability. Defaults to true . - metrics : Configure a statsd server to send metrics to. - statsd : The host and port to send metrics to. Defaults to STATSD_SERVER environment variable or in case it is not defined, then it defaults to null , which disables metric submission. - prefix : A prefix for every metric, defaults to symbolicator . - hostname_tag : If set, report the current hostname under the given tag name for all metrics. - environment_tag : If set, report the current environment under the given tag name for all metrics. - sentry_dsn : DSN to a Sentry project for internal error reporting. Defaults to null , which disables reporting to Sentry. - sources : An optional list of preconfigured sources. If these are configured they will be used as default sources for symbolication requests and they will be proxied by the symbol proxy if enabled. The format for the sources here matches the sources in the HTTP API. - symstore_proxy : Enables or disables the symstore proxy mode. Creates an endpoint to download raw symbols from configured sources Symbolicator as if it were a symstore (Microsoft Symbol Server) compatible server. Defaults to true . - connect_to_reserved_ips : Allow reserved IP addresses for requests to sources. See Security . Defaults to false . - max_concurrent_requests : The maximum number of requests symbolicator will process concurrently. Further requests will result in a 503 status code. Set it to null to turn off the limit. Defaults to 120. All time units for the following configuration settings can be either a time expression like 1s . Units can be s , seconds , m , minutes , h , hours , d , days , w , weeks , M , months , y , years . max_download_timeout : The timeout for downloading debug files. connect_timeout : The timeout for establishing a connection to a symbol server to download debug files. streaming_timeout : The timeout for streaming the contents of a debug file. caches : Fine-tune cache expiry. Time units for caches may also be null to disable cache expiration. downloaded : Fine-tune caches for downloaded files. max_unused_for : Maximum duration to keep a file since last use of it. retry_misses_after : Duration to wait before re-trying to download a file which was not found. retry_malformed_after : Duration to wait before re-trying to download a file which was malformed. max_lazy_redownloads : Symbolicator will fall back to a compatible but out-of-date cache version if available, and start computing the up-to-date version in the background. This option sets the maximum number of such lazy downloads that symbolicator will do concurrently. Defaults to 50. derived : Fine-tune caches for files which are derived from downloaded files. These files are usually versions of the downloaded files optimised for fast lookups. max_unused_for : Maximum duration to keep a file since last use of it. retry_misses_after : Duration to wait before re-trying to download a file which was not found. retry_malformed_after : Duration to wait before re-trying to download a file which was malformed. max_lazy_recomputations : Symbolicator will fall back to a compatible but out-of-date cache version if available, and start computing the up-to-date version in the background. This option sets the maximum number of such lazy computations that symbolicator will do concurrently. Defaults to 20. diagnostics : This configures the duration diagnostics data will be stored in cache. E.g. minidumps which failed to be processed correctly will be stored in this cache. retention : Duration a file will be kept in this cache.","title":"Configuration"},{"location":"#security","text":"By default, Symbolicator does not try to download debug files from reserved IP ranges . This ensures that no unintended connections are made to internal systems when source configuration is passed in from an untrusted source. To allow internal connections, set connect_to_reserved_ips to true . An exception from this rule is the \"sentry\" source type. Sentry is expected to run within the same network as Symbolicator, which is why it is exempt by default.","title":"Security"},{"location":"advanced/background-and-principles/","text":"Background and Principles This page describes reasoning behind the design of Symbolicator. Symbolicator Principles Symbolizer is a service that unifies symbolication for all kinds of native frames and allows us to add more features or improve performance more easily than in the former setup. Goals of the Symbolizer are: Symbolize entire stack traces at once , referencing both system- and customer images. Thanks to this, heuristics for detecting system images are no longer necessary. Fetch DIFs from external sources. These could be third-party servers like the online Microsoft Symbol Server or buckets of DIFs hosted by our customers. This removes the need to proactively upload files to Sentry that will never be used. Treat SymCaches and Debug Files as transient. All files are put in a local file system cache for faster access, but there is no persistent storage for symcaches or files retrieved from an external resources. This also simplifies upgrades (simply wipe the cache). Avoid one-hit wonders. SymCaches only need to be generated for debug files that are hit multiple times within a time frame. For all other symbols, using the original debug file is sufficiently fast \u2014 especially since it only needs to be loaded once per symbolication request. Improve processing of minidumps. Potentially use multiple debug files or cache files at once to run stackwalking and symbolication in a single run. This reduces resource allocation and gets rid of our hacks in the breakpad processor. Issues Symbolicator Solves Symbolicator was developed at [Sentry] to allow for faster iteration speeds and improve symboilcation performance. There were a couple of general issues with native event processing: Matching of system symbol paths sometimes yields false positives SymbolServer only handles iOS system symbols and cannot resolve line numbers Handling of DIFs in Sentry causes a lot of overhead in the blob storage and is prone to race conditions Customers are starting to hit the maximum file size limit of 2GB DIFs always need to be uploaded before events, whether they are used or not Minidump processing requires multiple debug files at once, which required hacks in Sentry. Additionally, there were issues around the upload of debug information files. SymCaches and CFI caches are computed ahead of time and persisted. This creates inherent race conditions and also requires computation, even if the symbols are never used. Debug file models only store the debug identifier. This works for Breakpad minidumps and custom SDKs, but will never be compatible to native debuggers or other systems. The old logic for choosing files based on debug ids is based on the upload time. This was done to reduce the amount of fetching from the file storage onto workers. However, this might choose a suboptimal file. During symbol upload, older \"redundant\" files are deleted. A file is considered redundant, if it only provides a subset of the features of all newer files combined. Since this does not consider the file type, this might throw away better debug information in favor of a newer, worse file (e.g. when a breakpad file is uploaded after the original debug file). Terminology Debug Information Files DIFs contain \"debug information\" to resolve function names and file locations from raw memory addresses in native crash reports. These files can get quite large, and we have encountered first customers with files over 2GB. Additionally, DIFs come in various different formats depending on the operating system and build process. In some scenarios, a combination of multiple files might be needed to successfully symbolicate a native crash. This has first been encountered in minidumps, which require the executable to extract stack traces, but a separate debug file to symbolicate its addresses. To mitigate issues with file size and platform differences, we created SymCaches . These are custom binary files that store an essential subset of the original debug information in a uniform format. The file format is optimized for direct mapping into memory and fast lookups of addresses. SymCaches are created for every DIF uploaded by customers that contains valid debug information.","title":"Background and Principles"},{"location":"advanced/background-and-principles/#background-and-principles","text":"This page describes reasoning behind the design of Symbolicator.","title":"Background and Principles"},{"location":"advanced/background-and-principles/#symbolicator-principles","text":"Symbolizer is a service that unifies symbolication for all kinds of native frames and allows us to add more features or improve performance more easily than in the former setup. Goals of the Symbolizer are: Symbolize entire stack traces at once , referencing both system- and customer images. Thanks to this, heuristics for detecting system images are no longer necessary. Fetch DIFs from external sources. These could be third-party servers like the online Microsoft Symbol Server or buckets of DIFs hosted by our customers. This removes the need to proactively upload files to Sentry that will never be used. Treat SymCaches and Debug Files as transient. All files are put in a local file system cache for faster access, but there is no persistent storage for symcaches or files retrieved from an external resources. This also simplifies upgrades (simply wipe the cache). Avoid one-hit wonders. SymCaches only need to be generated for debug files that are hit multiple times within a time frame. For all other symbols, using the original debug file is sufficiently fast \u2014 especially since it only needs to be loaded once per symbolication request. Improve processing of minidumps. Potentially use multiple debug files or cache files at once to run stackwalking and symbolication in a single run. This reduces resource allocation and gets rid of our hacks in the breakpad processor.","title":"Symbolicator Principles"},{"location":"advanced/background-and-principles/#issues-symbolicator-solves","text":"Symbolicator was developed at [Sentry] to allow for faster iteration speeds and improve symboilcation performance. There were a couple of general issues with native event processing: Matching of system symbol paths sometimes yields false positives SymbolServer only handles iOS system symbols and cannot resolve line numbers Handling of DIFs in Sentry causes a lot of overhead in the blob storage and is prone to race conditions Customers are starting to hit the maximum file size limit of 2GB DIFs always need to be uploaded before events, whether they are used or not Minidump processing requires multiple debug files at once, which required hacks in Sentry. Additionally, there were issues around the upload of debug information files. SymCaches and CFI caches are computed ahead of time and persisted. This creates inherent race conditions and also requires computation, even if the symbols are never used. Debug file models only store the debug identifier. This works for Breakpad minidumps and custom SDKs, but will never be compatible to native debuggers or other systems. The old logic for choosing files based on debug ids is based on the upload time. This was done to reduce the amount of fetching from the file storage onto workers. However, this might choose a suboptimal file. During symbol upload, older \"redundant\" files are deleted. A file is considered redundant, if it only provides a subset of the features of all newer files combined. Since this does not consider the file type, this might throw away better debug information in favor of a newer, worse file (e.g. when a breakpad file is uploaded after the original debug file).","title":"Issues Symbolicator Solves"},{"location":"advanced/background-and-principles/#terminology","text":"","title":"Terminology"},{"location":"advanced/background-and-principles/#debug-information-files","text":"DIFs contain \"debug information\" to resolve function names and file locations from raw memory addresses in native crash reports. These files can get quite large, and we have encountered first customers with files over 2GB. Additionally, DIFs come in various different formats depending on the operating system and build process. In some scenarios, a combination of multiple files might be needed to successfully symbolicate a native crash. This has first been encountered in minidumps, which require the executable to extract stack traces, but a separate debug file to symbolicate its addresses. To mitigate issues with file size and platform differences, we created SymCaches . These are custom binary files that store an essential subset of the original debug information in a uniform format. The file format is optimized for direct mapping into memory and fast lookups of addresses. SymCaches are created for every DIF uploaded by customers that contains valid debug information.","title":"Debug Information Files"},{"location":"advanced/caching/","text":"Caching Conceptionally, Symbolicator does not store debug information files but treats them as transient caches. Symbolicator caches two types of files: Raw debug information files and symbolication caches. Cache Files Symbolicator caches two kinds of files: original Debug Information Files and derived caches which comprise SymCaches and CFI caches. Debug Information Files (Object Files) (original): The original debug files as they are stored on external sources. They are cached to allow for faster recomputation of the derived caches, especially when after an update the format of the derived caches change. Otherwise, all original files would have to be downloaded again which could incur significant performance impact. DIFs are platform dependent and usually large in size, up to multiple GB. Their internal structure is platform dependent. Object Meta Files (derived): Important attributes of a Object File used to determine which Object File is the best one. This information is persisted separately from Object Files because we want to delete Object Files a few days after download for disk we want to delete Object Files a few days after download for disk space while still knowing some information about them. Symbolication Caches (derived): A platform-independent representation of function and line information to symbolicate instruction addresses. Those files are usually significantly smaller than native DIFs. However, endianness of the file contents depends on the host so these files cannot be transferred between systems with different endianness. CFI Caches (derived): A platform-independent representation of stack unwind information to allow stackwalking. This currently uses the Breakpad ASCII format. Cache Rules In addition to caching DIFs and derived caches, Symbolicator also stores placeholders to indicate the absence of or errors when retrieving or computing those files. The cache adheres to the following rules: DIFs are cached until they have not been used for 7 days but may be deleted earlier when disk space is running out. A DIF is used when a derived cache is computed from it. Derived caches that were successfully created from preferred DIFs are cached until they have not been used for at least 7 days . Derived caches that were successfully created from fallback DIFs are treated equally but at most once per hour an upgrade attempt is started to search for better DIFs. The absence of a DIF is cached for 1 hour , after that another fetch attempt from all sources is started. Failed conversions (due to malformed or unsupported debug files) are cached for 24 hours but only up to the next restart . After that, another conversion is attempted. The restart constraint serves the purpose to allow immediate bug fixes. Derived caches can continue to be stored independently of the DIFs they were created from. Because they are smaller than the originals, this contributes to a better use of the available disk space. All timeouts mentioned above are configurable: caches : downloaded : max_unused_for : 7 d # unused DIFs, rule 1 retry_misses_after : 1 h # absence of a DIF, rule 4 derived : max_unused_for : 7 d # unused caches, rule 2 retry_misses_after : 1 h # also necessary for rule 4 Cache Enforcement In order to enforce the desired cache behavior, Symbolicator uses file system meta data and information stored in the files themselves to determine when to evict items from the cache. Last use of derived cache : The time when a derived cache was last used in a symbolication request. This allows to prune cold caches from the system, even from an external service. This value is stored in the mtime of the symbolication file and updated at most once per hour . Last attempt to fetch dependencies of a cache: The time when the a derived cache could not be constructed because no debug files were available. Instead, a placeholder cache file is created and its mtime indicates the attempt. If this file is older than the threshold (default 1 hour ), another fetch attempt can be started and the file is recreated or replaced. NOTE : The placeholder is created for the derived cache only, because otherwise too many placeholders would be created. Last failed cache conversion : The time when deriving a cache from a native DIF failed due to an error. A placeholder file is created and its mtime indicates the attempt. If a file is older than the threshold (default 24 hours ), conversion is repeated. If the debug files have been deleted in between, this causes another fetch from external sources. DIFs used for derived cache : The kind of debug information that was used to compute a derived cache. SymCaches store this in their header, so this can be retrieved inexpensively by opening the file. CFI caches currently do not contain this information, although all DIFs offer equal quality of unwind information. Last cache upgrade: The last time when an upgrade of an existing derived cache was attempted since it was not computed from a preferred source. This also uses the file\u2019s mtime and attempts an update every time the modification time exceeds the threshold. Scopes Cached files are associated to a scope, which is given by the symbolication request. The default is a \u201cglobal\u201d scope, which implicitly makes the files accessible to any request (scoped and not scoped). Otherwise, the scope needs to match for caches to be used. Note that there is no verification of the scope number, so users of Symbolicator are required to ensure the soundness of scope values. Scoping is achieved by encoding the scope identifier into the cache paths, thus creating separate cache directories for each scope. Pruning Caches The symbolicator cleanup command removes stale caches. This command needs to be run manually and periodically, or at least when disk space is about to run out. Symbolicator operates under the assumption that files may be removed by an external actor at any time (one such actor is symbolicator cleanup itself which does not really attempt to synchronize with the main symbolicator service). Symbolicator assumes a fully POSIX-compliant filesystem to be able to serve requests without interruptions while files are being deleted. Using a network share for the cache folder will not work.","title":"Caching"},{"location":"advanced/caching/#caching","text":"Conceptionally, Symbolicator does not store debug information files but treats them as transient caches. Symbolicator caches two types of files: Raw debug information files and symbolication caches.","title":"Caching"},{"location":"advanced/caching/#cache-files","text":"Symbolicator caches two kinds of files: original Debug Information Files and derived caches which comprise SymCaches and CFI caches. Debug Information Files (Object Files) (original): The original debug files as they are stored on external sources. They are cached to allow for faster recomputation of the derived caches, especially when after an update the format of the derived caches change. Otherwise, all original files would have to be downloaded again which could incur significant performance impact. DIFs are platform dependent and usually large in size, up to multiple GB. Their internal structure is platform dependent. Object Meta Files (derived): Important attributes of a Object File used to determine which Object File is the best one. This information is persisted separately from Object Files because we want to delete Object Files a few days after download for disk we want to delete Object Files a few days after download for disk space while still knowing some information about them. Symbolication Caches (derived): A platform-independent representation of function and line information to symbolicate instruction addresses. Those files are usually significantly smaller than native DIFs. However, endianness of the file contents depends on the host so these files cannot be transferred between systems with different endianness. CFI Caches (derived): A platform-independent representation of stack unwind information to allow stackwalking. This currently uses the Breakpad ASCII format.","title":"Cache Files"},{"location":"advanced/caching/#cache-rules","text":"In addition to caching DIFs and derived caches, Symbolicator also stores placeholders to indicate the absence of or errors when retrieving or computing those files. The cache adheres to the following rules: DIFs are cached until they have not been used for 7 days but may be deleted earlier when disk space is running out. A DIF is used when a derived cache is computed from it. Derived caches that were successfully created from preferred DIFs are cached until they have not been used for at least 7 days . Derived caches that were successfully created from fallback DIFs are treated equally but at most once per hour an upgrade attempt is started to search for better DIFs. The absence of a DIF is cached for 1 hour , after that another fetch attempt from all sources is started. Failed conversions (due to malformed or unsupported debug files) are cached for 24 hours but only up to the next restart . After that, another conversion is attempted. The restart constraint serves the purpose to allow immediate bug fixes. Derived caches can continue to be stored independently of the DIFs they were created from. Because they are smaller than the originals, this contributes to a better use of the available disk space. All timeouts mentioned above are configurable: caches : downloaded : max_unused_for : 7 d # unused DIFs, rule 1 retry_misses_after : 1 h # absence of a DIF, rule 4 derived : max_unused_for : 7 d # unused caches, rule 2 retry_misses_after : 1 h # also necessary for rule 4","title":"Cache Rules"},{"location":"advanced/caching/#cache-enforcement","text":"In order to enforce the desired cache behavior, Symbolicator uses file system meta data and information stored in the files themselves to determine when to evict items from the cache. Last use of derived cache : The time when a derived cache was last used in a symbolication request. This allows to prune cold caches from the system, even from an external service. This value is stored in the mtime of the symbolication file and updated at most once per hour . Last attempt to fetch dependencies of a cache: The time when the a derived cache could not be constructed because no debug files were available. Instead, a placeholder cache file is created and its mtime indicates the attempt. If this file is older than the threshold (default 1 hour ), another fetch attempt can be started and the file is recreated or replaced. NOTE : The placeholder is created for the derived cache only, because otherwise too many placeholders would be created. Last failed cache conversion : The time when deriving a cache from a native DIF failed due to an error. A placeholder file is created and its mtime indicates the attempt. If a file is older than the threshold (default 24 hours ), conversion is repeated. If the debug files have been deleted in between, this causes another fetch from external sources. DIFs used for derived cache : The kind of debug information that was used to compute a derived cache. SymCaches store this in their header, so this can be retrieved inexpensively by opening the file. CFI caches currently do not contain this information, although all DIFs offer equal quality of unwind information. Last cache upgrade: The last time when an upgrade of an existing derived cache was attempted since it was not computed from a preferred source. This also uses the file\u2019s mtime and attempts an update every time the modification time exceeds the threshold.","title":"Cache Enforcement"},{"location":"advanced/caching/#scopes","text":"Cached files are associated to a scope, which is given by the symbolication request. The default is a \u201cglobal\u201d scope, which implicitly makes the files accessible to any request (scoped and not scoped). Otherwise, the scope needs to match for caches to be used. Note that there is no verification of the scope number, so users of Symbolicator are required to ensure the soundness of scope values. Scoping is achieved by encoding the scope identifier into the cache paths, thus creating separate cache directories for each scope.","title":"Scopes"},{"location":"advanced/caching/#pruning-caches","text":"The symbolicator cleanup command removes stale caches. This command needs to be run manually and periodically, or at least when disk space is about to run out. Symbolicator operates under the assumption that files may be removed by an external actor at any time (one such actor is symbolicator cleanup itself which does not really attempt to synchronize with the main symbolicator service). Symbolicator assumes a fully POSIX-compliant filesystem to be able to serve requests without interruptions while files are being deleted. Using a network share for the cache folder will not work.","title":"Pruning Caches"},{"location":"advanced/shared-cache/","text":"Shared Cache When running multiple symbolicators each instance has its own local cache. Starting up a new symbolicator instance in such an environment means it will have a cold cache and take a long time before it can process events at the same rate. To remedy this symbolicators can be configured to share their caches. When configured like this all caches will be shared, both original files and derived caches, thus a new symbolicator will not need to do all the computation to create missing common derived caches. However cache-computation is not coordinated, so if new caches are needed the shared cache works on a first-write-wins principle as all caches are identical for a given cache key. Configuration The shared cache is enabled by adding a new map in the config file: shared_cache : # The number of allowed concurrent uploads to the shared cache. # # Uploading to the shared cache is not critical for symbolicator's operation and # should not disrupt any normal work it does. This limits the number of concurrent # uploads so that associated resources are kept in check. max_concurrent_uploads : 20 # The number of queued up uploads to the cache. # # If more items need to be uploaded to the shared cache than there are allowed # concurrently the uploads will be queued. If the queue is full the uploads are # simply dropped as they are not critical to symbolicator's operation and not # disrupting symbolicator is more important than uploading to the shared cache. max_upload_queue_size : 100 # In production only Google Cloud Service is supported. gcs : # Required bucket : \"bucket-name\" # Optional name to service account .json file # # If not used the GCP internal metadata service will be used to retrieve tokens. service_account_path : \"/path/to/service-account.json\" # For testing an alternative backend is supported, this **can not** be used # at the same time as the `gcs` option. filesystem : path : \"/some/path/to/a/dir/\"","title":"Shared Cache"},{"location":"advanced/shared-cache/#shared-cache","text":"When running multiple symbolicators each instance has its own local cache. Starting up a new symbolicator instance in such an environment means it will have a cold cache and take a long time before it can process events at the same rate. To remedy this symbolicators can be configured to share their caches. When configured like this all caches will be shared, both original files and derived caches, thus a new symbolicator will not need to do all the computation to create missing common derived caches. However cache-computation is not coordinated, so if new caches are needed the shared cache works on a first-write-wins principle as all caches are identical for a given cache key.","title":"Shared Cache"},{"location":"advanced/shared-cache/#configuration","text":"The shared cache is enabled by adding a new map in the config file: shared_cache : # The number of allowed concurrent uploads to the shared cache. # # Uploading to the shared cache is not critical for symbolicator's operation and # should not disrupt any normal work it does. This limits the number of concurrent # uploads so that associated resources are kept in check. max_concurrent_uploads : 20 # The number of queued up uploads to the cache. # # If more items need to be uploaded to the shared cache than there are allowed # concurrently the uploads will be queued. If the queue is full the uploads are # simply dropped as they are not critical to symbolicator's operation and not # disrupting symbolicator is more important than uploading to the shared cache. max_upload_queue_size : 100 # In production only Google Cloud Service is supported. gcs : # Required bucket : \"bucket-name\" # Optional name to service account .json file # # If not used the GCP internal metadata service will be used to retrieve tokens. service_account_path : \"/path/to/service-account.json\" # For testing an alternative backend is supported, this **can not** be used # at the same time as the `gcs` option. filesystem : path : \"/some/path/to/a/dir/\"","title":"Configuration"},{"location":"advanced/source-bundles/","text":"Source Bundles Symbolicator supports the concept of source bundles. These are zip archives containing source code that goes along debug information files. These archives can be created with the sentry-cli tool as well as symsorter and are also supported by the underlying symbolic library. Source bundles are ZIP archives with a well-defined internal structure. Most importantly, they contain source files in a nested directory structure. Additionally, there is meta data associated to every source file, which allows to store additional properties, such as the original file system path, a web URL, and custom headers. Header The source bundle is a regular ZIP archive but has a special header prepended to identify it uniquely as source bundle. The header is in little endian: BUNDLE_MAGIC : [ u8 ; 4 ] BUNDLE_VERSION : u32 The bundle magic is always ASCII \"SYSB\" (symbolic source bundle) Structure The internal structure is as follows: manifest.json files/ file1.txt subfolder/ file2.txt Manifest The manifest is a JSON file with the following structure: { \"files\" : { \"path/in/bundle\" : { \"type\" : \"source\" , \"path\" : \"original/file/name\" , } }, \"code_id\" : \"CODE_ID\" , \"debug_id\" : \"DEBUG_ID\" , \"object_name\" : \"OBJECT_NAME\" , \"arch\" : \"ARCHITECTURE\" } The attributes must match the attributes of the debug information file (.pdb, or DWARF file) that goes along with it. Example Manifest: { \"files\" : { \"files/actix-web-0.7.19/src/server/h1.rs\" : { \"type\" : \"source\" , \"path\" : \"/usr/local/cargo/registry/src/github.com-1ecc6299db9ec823/actix-web-0.7.19/src/server/h1.rs\" }, ... }, \"arch\" : \"x86_64\" , \"code_id\" : \"f53af9062b83bc3b6dfd27a46912605f23e874de\" , \"debug_id\" : \"06f93af5-832b-3bbc-6dfd-27a46912605f\" , \"object_name\" : \"relay\" } In this case the source file needs to be stored in the following location in the bundle: files/actix-web-0.7.19/src/server/h1.rs .","title":"Source Bundles"},{"location":"advanced/source-bundles/#source-bundles","text":"Symbolicator supports the concept of source bundles. These are zip archives containing source code that goes along debug information files. These archives can be created with the sentry-cli tool as well as symsorter and are also supported by the underlying symbolic library. Source bundles are ZIP archives with a well-defined internal structure. Most importantly, they contain source files in a nested directory structure. Additionally, there is meta data associated to every source file, which allows to store additional properties, such as the original file system path, a web URL, and custom headers.","title":"Source Bundles"},{"location":"advanced/source-bundles/#header","text":"The source bundle is a regular ZIP archive but has a special header prepended to identify it uniquely as source bundle. The header is in little endian: BUNDLE_MAGIC : [ u8 ; 4 ] BUNDLE_VERSION : u32 The bundle magic is always ASCII \"SYSB\" (symbolic source bundle)","title":"Header"},{"location":"advanced/source-bundles/#structure","text":"The internal structure is as follows: manifest.json files/ file1.txt subfolder/ file2.txt","title":"Structure"},{"location":"advanced/source-bundles/#manifest","text":"The manifest is a JSON file with the following structure: { \"files\" : { \"path/in/bundle\" : { \"type\" : \"source\" , \"path\" : \"original/file/name\" , } }, \"code_id\" : \"CODE_ID\" , \"debug_id\" : \"DEBUG_ID\" , \"object_name\" : \"OBJECT_NAME\" , \"arch\" : \"ARCHITECTURE\" } The attributes must match the attributes of the debug information file (.pdb, or DWARF file) that goes along with it. Example Manifest: { \"files\" : { \"files/actix-web-0.7.19/src/server/h1.rs\" : { \"type\" : \"source\" , \"path\" : \"/usr/local/cargo/registry/src/github.com-1ecc6299db9ec823/actix-web-0.7.19/src/server/h1.rs\" }, ... }, \"arch\" : \"x86_64\" , \"code_id\" : \"f53af9062b83bc3b6dfd27a46912605f23e874de\" , \"debug_id\" : \"06f93af5-832b-3bbc-6dfd-27a46912605f\" , \"object_name\" : \"relay\" } In this case the source file needs to be stored in the following location in the bundle: files/actix-web-0.7.19/src/server/h1.rs .","title":"Manifest"},{"location":"advanced/symbol-lookup/","text":"Lookup Strategy Symbolicator queries a list of external sources for debug information files which it uses to process minidumps and symbolicate stack traces. Based on availability, the CPU architecture and the operating system, it may determine the \"best\" file to use: Compute the code and debug identifiers for the modules to load. Look up available files in all sources Choose the best available file Identifiers Symbol servers use native identifiers to locate files. Usually, they put them in a directory hierarchy for easier retrieval. There are two kinds of identifiers: Code Id: Native identifier of the actual binary (library or executable). Usually, this is a value stored in the header or computed from its contents. Debug Id: Identifier of the associated debug file on some platforms, or a mangled version of the code identifier on other platforms. To look up different symbol kinds, the symbol server uses the following process to determine the ID (see below for exact conversion algorithms): MachO: Use the UUID which is stored interchangeably in debug_id and code_id . If one of these values is missing, it can be computed from the other. Primarily, the code_id should be used. ELF: Use the GNU build id which is given in the code_id . The debug_id can be computed from this code_id , but not the other way around. Thus, if the code_id is missing, lookups may not be possible. PE : Windows executables use a combination of timestamp and size fields to compute a code_id . It is mandatory, as it cannot be derived from the debug_id . PDB : Windows PDBs have their own debug_id , which can be read from the PDB or PE header. It is mandatory, as it cannot be derived from the code_id . Breakpad : Google Breakpad uses debug_id for all symbol kinds. If it is missing, it can be computed from the code_id if this is possible using the above rules. Symbol Precedence Depending on the desired information and type of image, the Symbolicator requests several files and chooses the best one. Note that the image type depends on the platform, but there are multiple formats for debug information files available. The following is a table of what we initially deemed as ideal lookup strategy. How we deviate from this in practice is documented separately. Symbol Table Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) MachO (code) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB PE Breakpad Debug Information Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB Breakpad Unwind Information Platform 1. Choice 2. Choice MachO MachO (code) Breakpad ELF ELF (code) Breakpad PE (32-bit) PDB Breakpad PE (64-bit) PE Breakpad Implementation Notes Symbolicator downloads all filetypes in parallel and filters by whether symbolic says that a file has debug/unwind information. There is no special codepath for each table presented here, and especially not for each platform/filetype. This creates a few more downloads than what would be necessary for a specific task, but those should not matter considering that you e.g. will likely look into debug information very soon if you already look for unwind information. As a result of the previous point, Symbolicator does not differentiate between 32-bit and 64-bit platforms, meaning that even on 64-bit Windows it will attempt to look into the PDB to find relevant information. Again this should not matter in terms of correctness as it will still also unconditionally look into the PE and pick that if it's deemed to be be of better quality. Conversion Algorithms Some identifiers may be computed from others. See the following list for allowed non-lossy conversions in pseudocode: MachO : code_id \u2190\u2192 debug_id . Symbolicator implements this by using the code ID everywhere. ELF : code_id \u2192 debug_id . This is not yet implemented. debug_id = code_id [ 0 .. 16 ] if object . little_endian { debug_id [ 0 .. 4 ]. reverse () ; // uuid field 1 debug_id [ 4 .. 6 ]. reverse () ; // uuid field 2 debug_id [ 6 .. 8 ]. reverse () ; // uuid field 3 }","title":"Lookup Strategy"},{"location":"advanced/symbol-lookup/#lookup-strategy","text":"Symbolicator queries a list of external sources for debug information files which it uses to process minidumps and symbolicate stack traces. Based on availability, the CPU architecture and the operating system, it may determine the \"best\" file to use: Compute the code and debug identifiers for the modules to load. Look up available files in all sources Choose the best available file","title":"Lookup Strategy"},{"location":"advanced/symbol-lookup/#identifiers","text":"Symbol servers use native identifiers to locate files. Usually, they put them in a directory hierarchy for easier retrieval. There are two kinds of identifiers: Code Id: Native identifier of the actual binary (library or executable). Usually, this is a value stored in the header or computed from its contents. Debug Id: Identifier of the associated debug file on some platforms, or a mangled version of the code identifier on other platforms. To look up different symbol kinds, the symbol server uses the following process to determine the ID (see below for exact conversion algorithms): MachO: Use the UUID which is stored interchangeably in debug_id and code_id . If one of these values is missing, it can be computed from the other. Primarily, the code_id should be used. ELF: Use the GNU build id which is given in the code_id . The debug_id can be computed from this code_id , but not the other way around. Thus, if the code_id is missing, lookups may not be possible. PE : Windows executables use a combination of timestamp and size fields to compute a code_id . It is mandatory, as it cannot be derived from the debug_id . PDB : Windows PDBs have their own debug_id , which can be read from the PDB or PE header. It is mandatory, as it cannot be derived from the code_id . Breakpad : Google Breakpad uses debug_id for all symbol kinds. If it is missing, it can be computed from the code_id if this is possible using the above rules.","title":"Identifiers"},{"location":"advanced/symbol-lookup/#symbol-precedence","text":"Depending on the desired information and type of image, the Symbolicator requests several files and chooses the best one. Note that the image type depends on the platform, but there are multiple formats for debug information files available. The following is a table of what we initially deemed as ideal lookup strategy. How we deviate from this in practice is documented separately.","title":"Symbol Precedence"},{"location":"advanced/symbol-lookup/#symbol-table","text":"Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) MachO (code) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB PE Breakpad","title":"Symbol Table"},{"location":"advanced/symbol-lookup/#debug-information","text":"Platform 1. Choice 2. Choice 3. Choice MachO MachO (dSYM) Breakpad ELF ELF (debug) ELF (code) Breakpad PE PDB Breakpad","title":"Debug Information"},{"location":"advanced/symbol-lookup/#unwind-information","text":"Platform 1. Choice 2. Choice MachO MachO (code) Breakpad ELF ELF (code) Breakpad PE (32-bit) PDB Breakpad PE (64-bit) PE Breakpad","title":"Unwind Information"},{"location":"advanced/symbol-lookup/#implementation-notes","text":"Symbolicator downloads all filetypes in parallel and filters by whether symbolic says that a file has debug/unwind information. There is no special codepath for each table presented here, and especially not for each platform/filetype. This creates a few more downloads than what would be necessary for a specific task, but those should not matter considering that you e.g. will likely look into debug information very soon if you already look for unwind information. As a result of the previous point, Symbolicator does not differentiate between 32-bit and 64-bit platforms, meaning that even on 64-bit Windows it will attempt to look into the PDB to find relevant information. Again this should not matter in terms of correctness as it will still also unconditionally look into the PE and pick that if it's deemed to be be of better quality.","title":"Implementation Notes"},{"location":"advanced/symbol-lookup/#conversion-algorithms","text":"Some identifiers may be computed from others. See the following list for allowed non-lossy conversions in pseudocode: MachO : code_id \u2190\u2192 debug_id . Symbolicator implements this by using the code ID everywhere. ELF : code_id \u2192 debug_id . This is not yet implemented. debug_id = code_id [ 0 .. 16 ] if object . little_endian { debug_id [ 0 .. 4 ]. reverse () ; // uuid field 1 debug_id [ 4 .. 6 ]. reverse () ; // uuid field 2 debug_id [ 6 .. 8 ]. reverse () ; // uuid field 3 }","title":"Conversion Algorithms"},{"location":"advanced/symbol-server-compatibility/","text":"Symbol Server Compatibility This page describes external sources supported by Symbolicator. The layout of external sources intends to be compatible to several symbol server implementations that have been used historically by different platforms. We commit to provide compatibility to the following services or directory structures: Microsoft Symbol Server Breakpad Symbol Repositories LLDB File Mapped UUID Directories GDB Build ID Directories debuginfod Unified Symbol Server Layout Lookup Types Symbolicator uses different lookup types to support different servers which do not map 1:1 to a symbol server. The two most common lookup types are native and unified . native This lookup type emulates the most \"native\" symbol server format depending on the file type. This for instance means for PDB and PE files this turns into Microsoft Symbol Server. It also adds support for breakpad and will use LLDB/GDB formats for MachO and ELF respectively. This symbol server type also has support for source bundles for all file types. unified This is the symbolicator proprietary but preferred source (Unified Symbol Server Layout) which adds a consistent lookup format for all architectures. It's used at Sentry for the internal symbol lookups (like Apple or Android symbols). Like The native format this supports source bundles. Prerequisites Identifiers There are two fundamentally different identifiers. Their semantics fundamentally depend on the symbol type, but follow certain rules: Code Identifier: Identifies the actual executable or library file (e.g. EXE or DLL) Debug Identifier: Identifies a debug companion file (e.g. PDB) On all platforms other than Windows, binaries and debug companion files use the same file type and share the same container. The Breakpad library has thus changed the semantics of those identifiers for all other platforms to: Code Identifier: The original platform-specific identifier Debug Identifier: A potentially lossy transformation of the code identifier into a unified format similar to the PDB debug identifiers. Specifically, the code and debug identifiers are defined as follows: ELF : Code ID: The contents of the .note.gnu.build-id section, or if not present the value of the NT_GNU_BUILD_ID program header. This value is traditionally 20 bytes formatted as hex string (40 characters). If neither are present, there is no code id. Debug ID: The first 16 bytes of the GNU build id interpreted as little-endian GUID. This flips the byte order of the first three components in the build ID. An age of 0 is appended at the end. The remaining bytes of the build ID are discarded. This identifier is only specified by Breakpad, but by SSQP. MachO : Code ID: The UUID as specified in the LC_UUID load command header. Breakpad does not save this value explicitly since it can be converted bidirectionally from the UUID. Debug ID: The same UUID, amended by a 0 for age. WASM : Code ID: The bytes as specified in the build_id custom section. Debug ID: The same as code ID but truncated to 16 bytes + 0 for age. PE / PDB : Code ID: The hex value of the time_date_stamp in the COFF header formatted as %08X followed by size_of_image in the optional header formatted as %X (variable length). This value is always read from the PE - computing this from a PDB is not possible without locating the according PE. Debug ID: The signature and age ( %X variable length) fields from the debug information stream in the PDB. The fields in the signature GUID are converted to network byte order first. This identifier can also be computed from a PE by reading the code_view_pdb_70 records. Breakpad : Code ID: If applicable, Breakpad symbols will contain a INFO CODE_ID record in the second line. Otherwise, the code ID is equal to the Debug ID. Debug ID : Value of the identifier field in the MODULE record, always in the first line of the file. Source Bundles : Symbolicator supports the concept of source bundles which are source archives which can be used to extract source code for crashes. These source bundles are an extension which are not available to all lookup types. Case Sensitivity Most symbol servers explicitly define case insensitive lookup semantics. This goes in particular for the Microsoft Public Symbol Server. However, the canonical representation on the file system is not necessarily case insensitive, for example when the files are stored on an Amazon S3 bucket. Since this is a hard restriction, the case for lookups is explicitly defined for each source below. Please pay attention to the casing rules! Compression Symbolicator supports a range of compression formats (zlib, gzip, zstd and cab). For cab compression, the cabextract binary needs to be installed. If the debug file is already compressed, it will be auto-detected and extracted. For PE/PDB files, Symbolicator also supports the Microsoft convention of replacing the last character in the filename with an underscore. Supported Servers Breakpad Breakpad always computes a \"Breakpad ID\" for each symbol. This is a lossy process depending on the file type. Sentry stores a bidirectionally compatible version of this in the debug_id field. The name of the symbol file is platform dependent. On Windows, the file extension (Either .exe , .dll or .pdb ) is replaced with .sym . On all other platforms, the .sym extension is appended to the full file name including potential extensions. Casing rules are mixed: The file name is as given The signature part of the id (first 32 characters) are uppercase The age part of the id (remaining characters) are lowercase Schema : <debug_name>/<breakpad-id>/<sym_name> The following layout types support this lookup: native symstore symstore_index2 ssqp Microsoft Symbol Server The public symbol server provided by Microsoft used to only host PDBs for the Windows platform. These use a signature-age debug identifier in addition to the file name to locate symbols. For .NET, this specification was amended by a schema for ELF and MachO-symbols, which is specified as SSQP Key Conventions . This means all non windows platforms are following SSQP rules except for casing. Casing rules for Symbol Server are mixed: Filenames are as given Identifiers are generally lowercase , except: The signature and age of a PDB identifier is uppercase . The timestamp of a PE identifier is uppercase except the size is lowercase Schema : PE : <code_name>/<Timestamp><SizeOfImage>/<code_name> PDB : <debug_name>/<Signature><Age>/<debug_name> ELF (binary, potentially stripped): <code_name>/elf-buildid-<note_byte_sequence>/<code_name> ELF (debug info): _.debug/elf-buildid-sym-<note_byte_sequence>/_.debug MachO (binary): <code_name>/mach-uuid-<uuid_bytes>/<code_name> MachO (dSYM): _.dwarf/mach-uuid-sym-<uuid_bytes>/_.dwarf The presence of a index2.txt in the root indicates two tier structure where the first two characters are prepended to the path as an additional folder. So foo.exe/542D5742000f2000/foo.exe is stored as fo/foo.exe/542D5742000f2000/foo.exe . Note that symbolicator does not probe for the index2.txt file. You need to be explicit in configuring it. Source bundles are only supported for PE/PDB files with the following format: Source bundle : <debug_name>/<Signature><Age>/<debug_name>.src.zip The following layout types support this lookup: symstore for a regular symbol server symstore_index2 for a symbol server with an index2.txt root. Microsoft SSQP Symbol Server Casing rules for SSQP are mixed: Filenames are lowercased Identifiers are generally lowercase , except: The age of a PDB identifier is uppercase . PE : <code_name>/<Timestamp><SizeOfImage>/<code_name> PDB : <debug_name>/<Signature><Age>/<debug_name> ELF (binary, potentially stripped): <code_name>/elf-buildid-<note_byte_sequence>/<code_name> ELF (debug info): _.debug/elf-buildid-sym-<note_byte_sequence>/_.debug MachO (binary): <code_name>/mach-uuid-<uuid_bytes>/<code_name> MachO (dSYM): _.dwarf/mach-uuid-sym-<uuid_bytes>/_.dwarf Additionally, SSQP supports a lookup by SHA1 checksum over the file contents, commonly used for source file lookups. This is not supported. Symbol bundles are only supported for PE/PDB files with the following format: Source bundle : <debug_name>/<Signature><Age>/<debug_name>.src.zip The following layout types support this lookup: ssqp LLDB Debugger (macOS) The LLDB debugger on macOS can read debug symbols from File Mapped UUID Directories (scroll down to the second last section). The UUID is broken up by splitting the first 20 hex digits into 4 character chunks, and a directory is created for each chunk. In the final directory, LLDB usually expects a symlink named by the last 12 hex digits, which it follows to the actual dSYM file. Note : this is not actually an LLVM feature. This is in fact a feature of CoreFoundation and exclusively implemented on macOS on top of spotlight. Spotlight indexes these paths and the private DBGCopyFullDSYMURLForUUID API is used by lldb to locate the symbols. macOS uses the symlinks of those locations. Since the executable or library shares the same UUID as the dSYM file, the former are distinguished with a .app suffix. The hex digits are uppercase , the app suffix is lowercase . MachO (binary): XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.app MachO (dSYM): XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX Symbol bundles are supported by adding a .src.zip prefix to the dsym: Source bundle : XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.src.zip The following layout types support this lookup: native GDB GDB supports multiple lookup methods, depending on the way the debug info file is specified. However, not all of these methods are applicable to a symbol server: Debug Link Method: GDB looks up the name or relative path specified in the .gnu.debuglink section. This requires the debug file to be in a relative position to the actual executable, and does not provide any means to distinguish by a unique identifier. Build ID Method: Assuming that a GNU build ID note or section have been written to the ELF file, this specifies a unique identifier for the executable which is also retained in the debug file. This method is applicable to a symbol server, but only if the Build ID is present. The GNU build ID is a variable-length binary string, usually consisting of a 20-byte SHA1 hash of the code section ( .text ). The lookup path is nn/nnnnnnnn.debug , where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. To look up executables, the .debug suffix is omitted. The build-id hex representation is always provided in lowercase . ELF (binary, potentially stripped) ELF (debug info) WASM (debug info) Symbol bundles are supported by adding a .src.zip prefix to the ELF: Source bundle : nn/nnnnnnnn.src.zip The following layout types support this lookup: native debuginfod Symbolicator also supports talking to debuginfod compatible servers for ELF and Macho. Schema : ELF (binary, potentially stripped): <code_note_byte_sequence>/executable ELF (debug info): <code_note_byte_sequence>/debuginfo Source bundles are not supported. The following layout types support this lookup: debuginfod Unified Symbol Server Layout If you have no requirements to be compatible with another system you can also use the \"unified\" directory layout structure. This has the advantage that it's unified across all platforms and thus easier to manage. It can store breakpad files, PDBs, PEs and everything else. The symsorter tool in the symbolicator repository can automatically sort debug symbols into this format and also automatically create source bundles. Schema : The debug id is in all cases lowercase in hex format and computed as follows: PE : <Signature><Age> (age in hex, not padded) PDB : <Signature><Age> (age in hex, not padded) ELF : <code_note_byte_sequence> MachO : <uuid_bytes> WASM : <BuildId> The path format is then as follows: binary: <DebugIdFirstTwo>/<DebugIdRest>/executable debug info: <DebugIdFirstTwo>/<DebugIdRest>/debuginfo breakpad: <DebugIdFirstTwo>/<DebugIdRest>/breakpad source bundle: <DebugIdFirstTwo>/<DebugIdRest>/sourcebundle The following layout types support this lookup: unified Other Servers The following additional sources were considered but are not implemented right now: Fedora Darkserver In 2010, Fedora launched a project called \"Darkserver\" that aimed to provide a symbol server for various libraries. In 2012, it seemed to have contained symbols for Debian and Ubuntu as well. However, this projects seems to have been abandoned since and there is only little information available. For now, there is no intention to support Darkserver. Mozilla Tecken Tecken is the symbol server implementation used at Mozilla. The symbol file paths are compatible to Google's Breakpad symbol server. An example of available symbols can be viewed at symbols.mozilla.org . Tecken internally implements a client for the Microsoft Symbol Server to forward downloads for missing symbols. While doing that, it attempts to replace the last character in the URL with an underscore to look up compressed symbols. In any case Tecken tries both variants. Example: foo.exe/<id>/foo.ex_ . Microsoft Symbol Server no longer supports this.","title":"Symbol Server Compatibility"},{"location":"advanced/symbol-server-compatibility/#symbol-server-compatibility","text":"This page describes external sources supported by Symbolicator. The layout of external sources intends to be compatible to several symbol server implementations that have been used historically by different platforms. We commit to provide compatibility to the following services or directory structures: Microsoft Symbol Server Breakpad Symbol Repositories LLDB File Mapped UUID Directories GDB Build ID Directories debuginfod Unified Symbol Server Layout","title":"Symbol Server Compatibility"},{"location":"advanced/symbol-server-compatibility/#lookup-types","text":"Symbolicator uses different lookup types to support different servers which do not map 1:1 to a symbol server. The two most common lookup types are native and unified .","title":"Lookup Types"},{"location":"advanced/symbol-server-compatibility/#native","text":"This lookup type emulates the most \"native\" symbol server format depending on the file type. This for instance means for PDB and PE files this turns into Microsoft Symbol Server. It also adds support for breakpad and will use LLDB/GDB formats for MachO and ELF respectively. This symbol server type also has support for source bundles for all file types.","title":"native"},{"location":"advanced/symbol-server-compatibility/#unified","text":"This is the symbolicator proprietary but preferred source (Unified Symbol Server Layout) which adds a consistent lookup format for all architectures. It's used at Sentry for the internal symbol lookups (like Apple or Android symbols). Like The native format this supports source bundles.","title":"unified"},{"location":"advanced/symbol-server-compatibility/#prerequisites","text":"","title":"Prerequisites"},{"location":"advanced/symbol-server-compatibility/#identifiers","text":"There are two fundamentally different identifiers. Their semantics fundamentally depend on the symbol type, but follow certain rules: Code Identifier: Identifies the actual executable or library file (e.g. EXE or DLL) Debug Identifier: Identifies a debug companion file (e.g. PDB) On all platforms other than Windows, binaries and debug companion files use the same file type and share the same container. The Breakpad library has thus changed the semantics of those identifiers for all other platforms to: Code Identifier: The original platform-specific identifier Debug Identifier: A potentially lossy transformation of the code identifier into a unified format similar to the PDB debug identifiers. Specifically, the code and debug identifiers are defined as follows: ELF : Code ID: The contents of the .note.gnu.build-id section, or if not present the value of the NT_GNU_BUILD_ID program header. This value is traditionally 20 bytes formatted as hex string (40 characters). If neither are present, there is no code id. Debug ID: The first 16 bytes of the GNU build id interpreted as little-endian GUID. This flips the byte order of the first three components in the build ID. An age of 0 is appended at the end. The remaining bytes of the build ID are discarded. This identifier is only specified by Breakpad, but by SSQP. MachO : Code ID: The UUID as specified in the LC_UUID load command header. Breakpad does not save this value explicitly since it can be converted bidirectionally from the UUID. Debug ID: The same UUID, amended by a 0 for age. WASM : Code ID: The bytes as specified in the build_id custom section. Debug ID: The same as code ID but truncated to 16 bytes + 0 for age. PE / PDB : Code ID: The hex value of the time_date_stamp in the COFF header formatted as %08X followed by size_of_image in the optional header formatted as %X (variable length). This value is always read from the PE - computing this from a PDB is not possible without locating the according PE. Debug ID: The signature and age ( %X variable length) fields from the debug information stream in the PDB. The fields in the signature GUID are converted to network byte order first. This identifier can also be computed from a PE by reading the code_view_pdb_70 records. Breakpad : Code ID: If applicable, Breakpad symbols will contain a INFO CODE_ID record in the second line. Otherwise, the code ID is equal to the Debug ID. Debug ID : Value of the identifier field in the MODULE record, always in the first line of the file. Source Bundles : Symbolicator supports the concept of source bundles which are source archives which can be used to extract source code for crashes. These source bundles are an extension which are not available to all lookup types.","title":"Identifiers"},{"location":"advanced/symbol-server-compatibility/#case-sensitivity","text":"Most symbol servers explicitly define case insensitive lookup semantics. This goes in particular for the Microsoft Public Symbol Server. However, the canonical representation on the file system is not necessarily case insensitive, for example when the files are stored on an Amazon S3 bucket. Since this is a hard restriction, the case for lookups is explicitly defined for each source below. Please pay attention to the casing rules!","title":"Case Sensitivity"},{"location":"advanced/symbol-server-compatibility/#compression","text":"Symbolicator supports a range of compression formats (zlib, gzip, zstd and cab). For cab compression, the cabextract binary needs to be installed. If the debug file is already compressed, it will be auto-detected and extracted. For PE/PDB files, Symbolicator also supports the Microsoft convention of replacing the last character in the filename with an underscore.","title":"Compression"},{"location":"advanced/symbol-server-compatibility/#supported-servers","text":"","title":"Supported Servers"},{"location":"advanced/symbol-server-compatibility/#breakpad","text":"Breakpad always computes a \"Breakpad ID\" for each symbol. This is a lossy process depending on the file type. Sentry stores a bidirectionally compatible version of this in the debug_id field. The name of the symbol file is platform dependent. On Windows, the file extension (Either .exe , .dll or .pdb ) is replaced with .sym . On all other platforms, the .sym extension is appended to the full file name including potential extensions. Casing rules are mixed: The file name is as given The signature part of the id (first 32 characters) are uppercase The age part of the id (remaining characters) are lowercase Schema : <debug_name>/<breakpad-id>/<sym_name> The following layout types support this lookup: native symstore symstore_index2 ssqp","title":"Breakpad"},{"location":"advanced/symbol-server-compatibility/#microsoft-symbol-server","text":"The public symbol server provided by Microsoft used to only host PDBs for the Windows platform. These use a signature-age debug identifier in addition to the file name to locate symbols. For .NET, this specification was amended by a schema for ELF and MachO-symbols, which is specified as SSQP Key Conventions . This means all non windows platforms are following SSQP rules except for casing. Casing rules for Symbol Server are mixed: Filenames are as given Identifiers are generally lowercase , except: The signature and age of a PDB identifier is uppercase . The timestamp of a PE identifier is uppercase except the size is lowercase Schema : PE : <code_name>/<Timestamp><SizeOfImage>/<code_name> PDB : <debug_name>/<Signature><Age>/<debug_name> ELF (binary, potentially stripped): <code_name>/elf-buildid-<note_byte_sequence>/<code_name> ELF (debug info): _.debug/elf-buildid-sym-<note_byte_sequence>/_.debug MachO (binary): <code_name>/mach-uuid-<uuid_bytes>/<code_name> MachO (dSYM): _.dwarf/mach-uuid-sym-<uuid_bytes>/_.dwarf The presence of a index2.txt in the root indicates two tier structure where the first two characters are prepended to the path as an additional folder. So foo.exe/542D5742000f2000/foo.exe is stored as fo/foo.exe/542D5742000f2000/foo.exe . Note that symbolicator does not probe for the index2.txt file. You need to be explicit in configuring it. Source bundles are only supported for PE/PDB files with the following format: Source bundle : <debug_name>/<Signature><Age>/<debug_name>.src.zip The following layout types support this lookup: symstore for a regular symbol server symstore_index2 for a symbol server with an index2.txt root.","title":"Microsoft Symbol Server"},{"location":"advanced/symbol-server-compatibility/#microsoft-ssqp-symbol-server","text":"Casing rules for SSQP are mixed: Filenames are lowercased Identifiers are generally lowercase , except: The age of a PDB identifier is uppercase . PE : <code_name>/<Timestamp><SizeOfImage>/<code_name> PDB : <debug_name>/<Signature><Age>/<debug_name> ELF (binary, potentially stripped): <code_name>/elf-buildid-<note_byte_sequence>/<code_name> ELF (debug info): _.debug/elf-buildid-sym-<note_byte_sequence>/_.debug MachO (binary): <code_name>/mach-uuid-<uuid_bytes>/<code_name> MachO (dSYM): _.dwarf/mach-uuid-sym-<uuid_bytes>/_.dwarf Additionally, SSQP supports a lookup by SHA1 checksum over the file contents, commonly used for source file lookups. This is not supported. Symbol bundles are only supported for PE/PDB files with the following format: Source bundle : <debug_name>/<Signature><Age>/<debug_name>.src.zip The following layout types support this lookup: ssqp","title":"Microsoft SSQP Symbol Server"},{"location":"advanced/symbol-server-compatibility/#lldb-debugger-macos","text":"The LLDB debugger on macOS can read debug symbols from File Mapped UUID Directories (scroll down to the second last section). The UUID is broken up by splitting the first 20 hex digits into 4 character chunks, and a directory is created for each chunk. In the final directory, LLDB usually expects a symlink named by the last 12 hex digits, which it follows to the actual dSYM file. Note : this is not actually an LLVM feature. This is in fact a feature of CoreFoundation and exclusively implemented on macOS on top of spotlight. Spotlight indexes these paths and the private DBGCopyFullDSYMURLForUUID API is used by lldb to locate the symbols. macOS uses the symlinks of those locations. Since the executable or library shares the same UUID as the dSYM file, the former are distinguished with a .app suffix. The hex digits are uppercase , the app suffix is lowercase . MachO (binary): XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.app MachO (dSYM): XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX Symbol bundles are supported by adding a .src.zip prefix to the dsym: Source bundle : XXXX/XXXX/XXXX/XXXX/XXXX/XXXXXXXXXXXX.src.zip The following layout types support this lookup: native","title":"LLDB Debugger (macOS)"},{"location":"advanced/symbol-server-compatibility/#gdb","text":"GDB supports multiple lookup methods, depending on the way the debug info file is specified. However, not all of these methods are applicable to a symbol server: Debug Link Method: GDB looks up the name or relative path specified in the .gnu.debuglink section. This requires the debug file to be in a relative position to the actual executable, and does not provide any means to distinguish by a unique identifier. Build ID Method: Assuming that a GNU build ID note or section have been written to the ELF file, this specifies a unique identifier for the executable which is also retained in the debug file. This method is applicable to a symbol server, but only if the Build ID is present. The GNU build ID is a variable-length binary string, usually consisting of a 20-byte SHA1 hash of the code section ( .text ). The lookup path is nn/nnnnnnnn.debug , where nn are the first 2 hex characters of the build ID bit string, and nnnnnnnn are the rest of the bit string. To look up executables, the .debug suffix is omitted. The build-id hex representation is always provided in lowercase . ELF (binary, potentially stripped) ELF (debug info) WASM (debug info) Symbol bundles are supported by adding a .src.zip prefix to the ELF: Source bundle : nn/nnnnnnnn.src.zip The following layout types support this lookup: native","title":"GDB"},{"location":"advanced/symbol-server-compatibility/#debuginfod","text":"Symbolicator also supports talking to debuginfod compatible servers for ELF and Macho. Schema : ELF (binary, potentially stripped): <code_note_byte_sequence>/executable ELF (debug info): <code_note_byte_sequence>/debuginfo Source bundles are not supported. The following layout types support this lookup: debuginfod","title":"debuginfod"},{"location":"advanced/symbol-server-compatibility/#unified-symbol-server-layout","text":"If you have no requirements to be compatible with another system you can also use the \"unified\" directory layout structure. This has the advantage that it's unified across all platforms and thus easier to manage. It can store breakpad files, PDBs, PEs and everything else. The symsorter tool in the symbolicator repository can automatically sort debug symbols into this format and also automatically create source bundles. Schema : The debug id is in all cases lowercase in hex format and computed as follows: PE : <Signature><Age> (age in hex, not padded) PDB : <Signature><Age> (age in hex, not padded) ELF : <code_note_byte_sequence> MachO : <uuid_bytes> WASM : <BuildId> The path format is then as follows: binary: <DebugIdFirstTwo>/<DebugIdRest>/executable debug info: <DebugIdFirstTwo>/<DebugIdRest>/debuginfo breakpad: <DebugIdFirstTwo>/<DebugIdRest>/breakpad source bundle: <DebugIdFirstTwo>/<DebugIdRest>/sourcebundle The following layout types support this lookup: unified","title":"Unified Symbol Server Layout"},{"location":"advanced/symbol-server-compatibility/#other-servers","text":"The following additional sources were considered but are not implemented right now:","title":"Other Servers"},{"location":"advanced/symbol-server-compatibility/#fedora-darkserver","text":"In 2010, Fedora launched a project called \"Darkserver\" that aimed to provide a symbol server for various libraries. In 2012, it seemed to have contained symbols for Debian and Ubuntu as well. However, this projects seems to have been abandoned since and there is only little information available. For now, there is no intention to support Darkserver.","title":"Fedora Darkserver"},{"location":"advanced/symbol-server-compatibility/#mozilla-tecken","text":"Tecken is the symbol server implementation used at Mozilla. The symbol file paths are compatible to Google's Breakpad symbol server. An example of available symbols can be viewed at symbols.mozilla.org . Tecken internally implements a client for the Microsoft Symbol Server to forward downloads for missing symbols. While doing that, it attempts to replace the last character in the URL with an underscore to look up compressed symbols. In any case Tecken tries both variants. Example: foo.exe/<id>/foo.ex_ . Microsoft Symbol Server no longer supports this.","title":"Mozilla Tecken"},{"location":"advanced/system-architecture/","text":"System Architecture This page describes the internal structure and processes of Symbolicator. Looking up debug/unwind information When finding an object file for a image in a symbolication request, we do the following: We generate all possible file downloads for each source, based on platform information and source filters. See Symbol Lookup . We download all files we can get and cache them keyed by source ID and filepath ( ObjectFile ). Then we rank all downloaded files: Objects with debug or unwind information (depending on what we want to use the object for) are ranked at the top. Objects with a symbol table are ranked second. Unparseable objects are ranked somewhere at the bottom together with empty files, 404s etc. Then we generate a symcache or cficache from the best file, save it also keyed by source ID and filepath. In the cache dir, a symcache file now basically has the same filename as an object file, just in a different folder. ObjectMeta The issue with the above setup is that one would have to have all objects permanently persisted on disk to be able to decide which symcache to use, which is only feasible in a world with infinite disk space. For this purpose we have the concept of an ObjectMeta cache, which stores information about the quality of an ObjectFile and is persisted for much longer. ObjectFile s are deleted just a few days after download while ObjectMeta s stick around for as long as the symcache/cficache does. The object cache key As mentioned earlier, ObjectFile s, symcaches/cficaches (and ObjectMeta s) are cached by source ID and filepath. What this actually means depends on the source type: For the HTTP source type (Microsoft SymStore etc) this is just the source ID as given in the symbolication request + the filepath of the download URL. For S3 and GCS buckets this is the source ID and the object key/path (object as in S3 object). For the Sentry source type this is the source ID and the numeric \"Debug File Id\". In summary, the cache key is just whatever is necessary to uniquely identify a file within a source. Generating all possible file downloads for a source In step 1, we mentioned that we generate all possible file downloads. For most filesystem-like source types this is a simple computation that takes an ObjectId (really a quintuple of debug and code ID + debug name + code name) and generates possible filepaths. The logic for this lives in src/utils/paths.rs . For the Sentry source type, this looks a bit different. Since Sentry already builds some sort of index based on debug and code ID, we first have to issue an HTTP request to Sentry to search for files based on those IDs. We get back a list of numeric \"Debug File Ids\" (those are just the integer PK in Postgres) that we then can download one by one. Since this step is quite expensive for Sentry, it is cached separately. This part is currently WIP. Example The logic for looking up debug information for an image looks as follows (simplified, conflating code_name vs debug_name + code_id vs debug_id): Lookup of object name=wkernel32.pdb, id=0xdeadbeef (uncached, parallelized): (cached) Fetching sentry index for id=0xdeadbeef (uncached) -> returns [123456] (cached) lookup of object metadata [sentry, 123456] -> returns has_debug_info=true, ... (cached) lookup of object file [sentry, 123456] (cached) lookup of object metadata [microsoft, /wkernel32.pdb/deadbeef/wkernel32.pdb] -> returns has_debug_info=false, ... (cached) lookup of object file [microsoft, /wkernel32.pdb/deadbeef/wkernel32.pdb] Sentry project symbol wins, because it has more than symbol table (cached) lookup of symcache [sentry, 123456] All steps that are behind a caching layer are prefixed with (cached) . If a cache hit occurs, the sub-bulletpoints are not executed.","title":"System Architecture"},{"location":"advanced/system-architecture/#system-architecture","text":"This page describes the internal structure and processes of Symbolicator.","title":"System Architecture"},{"location":"advanced/system-architecture/#looking-up-debugunwind-information","text":"When finding an object file for a image in a symbolication request, we do the following: We generate all possible file downloads for each source, based on platform information and source filters. See Symbol Lookup . We download all files we can get and cache them keyed by source ID and filepath ( ObjectFile ). Then we rank all downloaded files: Objects with debug or unwind information (depending on what we want to use the object for) are ranked at the top. Objects with a symbol table are ranked second. Unparseable objects are ranked somewhere at the bottom together with empty files, 404s etc. Then we generate a symcache or cficache from the best file, save it also keyed by source ID and filepath. In the cache dir, a symcache file now basically has the same filename as an object file, just in a different folder.","title":"Looking up debug/unwind information"},{"location":"advanced/system-architecture/#objectmeta","text":"The issue with the above setup is that one would have to have all objects permanently persisted on disk to be able to decide which symcache to use, which is only feasible in a world with infinite disk space. For this purpose we have the concept of an ObjectMeta cache, which stores information about the quality of an ObjectFile and is persisted for much longer. ObjectFile s are deleted just a few days after download while ObjectMeta s stick around for as long as the symcache/cficache does.","title":"ObjectMeta"},{"location":"advanced/system-architecture/#the-object-cache-key","text":"As mentioned earlier, ObjectFile s, symcaches/cficaches (and ObjectMeta s) are cached by source ID and filepath. What this actually means depends on the source type: For the HTTP source type (Microsoft SymStore etc) this is just the source ID as given in the symbolication request + the filepath of the download URL. For S3 and GCS buckets this is the source ID and the object key/path (object as in S3 object). For the Sentry source type this is the source ID and the numeric \"Debug File Id\". In summary, the cache key is just whatever is necessary to uniquely identify a file within a source.","title":"The object cache key"},{"location":"advanced/system-architecture/#generating-all-possible-file-downloads-for-a-source","text":"In step 1, we mentioned that we generate all possible file downloads. For most filesystem-like source types this is a simple computation that takes an ObjectId (really a quintuple of debug and code ID + debug name + code name) and generates possible filepaths. The logic for this lives in src/utils/paths.rs . For the Sentry source type, this looks a bit different. Since Sentry already builds some sort of index based on debug and code ID, we first have to issue an HTTP request to Sentry to search for files based on those IDs. We get back a list of numeric \"Debug File Ids\" (those are just the integer PK in Postgres) that we then can download one by one. Since this step is quite expensive for Sentry, it is cached separately. This part is currently WIP.","title":"Generating all possible file downloads for a source"},{"location":"advanced/system-architecture/#example","text":"The logic for looking up debug information for an image looks as follows (simplified, conflating code_name vs debug_name + code_id vs debug_id): Lookup of object name=wkernel32.pdb, id=0xdeadbeef (uncached, parallelized): (cached) Fetching sentry index for id=0xdeadbeef (uncached) -> returns [123456] (cached) lookup of object metadata [sentry, 123456] -> returns has_debug_info=true, ... (cached) lookup of object file [sentry, 123456] (cached) lookup of object metadata [microsoft, /wkernel32.pdb/deadbeef/wkernel32.pdb] -> returns has_debug_info=false, ... (cached) lookup of object file [microsoft, /wkernel32.pdb/deadbeef/wkernel32.pdb] Sentry project symbol wins, because it has more than symbol table (cached) lookup of symcache [sentry, 123456] All steps that are behind a caching layer are prefixed with (cached) . If a cache hit occurs, the sub-bulletpoints are not executed.","title":"Example"},{"location":"api/","text":"API Symbolicator exposes a HTTP API to allow symbolication of raw native stack traces and minidumps. All information necessary for symbolication needs to be part of the request, such as external buckets and their auth tokens or full stack traces. There are the following endpoints: POST /symbolicate : Symbolicate raw native stacktrace POST /minidump : Symbolicate a minidump and extract information POST /applecrashreport : Symbolicate an Apple Crash Report GET /requests/:id : Status update on running symbolication jobs GET /healthcheck : System status and health monitoring Sources For Symbolicator to operate correctly, it needs to be pointed to at least one source. It supports various different backends for where it looks for symbols. There are two modes for Symbolicator with regards to how it looks for symbols. One is the preconfigured mode where the sources key is configured right in the config file. The second is one where the sources are defined with the HTTP request to the symbolication API. If you want to use Symbolicator as a symstore compatible proxy you need to preconfigure the sources. Example configuration: [ { \"id\" : \"my-bucket-linux\" , \"type\" : \"s3\" , \"bucket\" : \"my-project-my-bucket\" , \"region\" : \"us-east-1\" , \"prefix\" : \"/linux\" , \"access_key\" : \"AMVSAVWEXRIRJPOMCKWN\" , \"secret_key\" : \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\" , \"filters\" : { \"filetypes\" : [ \"elf_debug\" , \"elf_code\" ] }, \"layout\" : { \"type\" : \"native\" , \"casing\" : \"lowercase\" } }, { \"id\" : \"my-bucket-windows\" , \"type\" : \"s3\" , \"bucket\" : \"my-project-my-bucket\" , \"region\" : \"us-east-1\" , \"prefix\" : \"/windows\" , \"access_key\" : \"AMVSAVWEXRIRJPOMCKWN\" , \"secret_key\" : \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\" , \"filters\" : { \"filetypes\" : [ \"pe\" , \"pdb\" ] }, \"layout\" : { \"type\" : \"native\" , \"casing\" : \"lowercase\" } }, { \"id\" : \"microsoft\" , \"type\" : \"http\" , \"filters\" : { \"filetypes\" : [ \"pe\" , \"pdb\" ] }, \"url\" : \"https://msdl.microsoft.com/download/symbols/\" } ] Sources are ordered by priority. Each source needs at least two keys: id : the ID of the source. This can be freely chosen and is used to identify cache files in the cache folder type : defines the type of the source ( http , s3 , gcs or sentry ) These are common parameters that work on most symbol sources (except sentry ): filters : a set of filters to reduce the number of unnecessary hits on a symbol server. This configuration key is an object with two keys: filetypes : a list of file types to restrict the server to. Possible values: pe , pdb , mach_debug , mach_code , elf_debug , elf_code , breakpad ) path_patterns : a list of glob matches that need to be matched on the image name. If the debug image has no name it will never match here. layout : configures the file system layout of the sources. This configuration key is an object with two keys: type : defines the general layout of the directory. Possible values are native , symstore , symstore_index2 , ssqp , and unified . native uses the file type's native format. symstore and ssqp both use the Microsoft Symbol Server format but control the case conventions. symstore uses the conventional casing rules for signatures and filenames, ssqp uses the Microsoft SSQP casing rules instead. Additionally symstore_index2 works like symstore but uses the \"Two tier\" (index2.txt) layout where the first two characters of the filename are used as a toplevel extra folder. unified is the unified lookup format that symbolicator recommends. casing : enforces a casing style. The default is not to touch the casing and forward it unchanged. If the backend does not support a case insensitive backend (eg: S3) then it's recommended to set this to lowercase to enforce changing all to lowercase. Possible values: default , lowercase , uppercase . HTTP source The HTTP source lets one fetch symbols from a Microsoft Symbol Server or similar systems. There is some flexibility to how it operates. type : \"http\" url : This defines the URL where symbolicator should be fetching from. For instance this can be https://msdl.microsoft.com/download/symbols/ to point it to the official microsoft symbol server. headers : an optional dictionary of headers that should be sent with the HTTP requests. This can be used for instance to configure HTTP basic auth configuration. Amazon S3 Bucket This source connects straight to an S3 bucket and looks for symbols there. It's recommended for this to be configured with explicit lowercase casing to avoid issues as the SSQP protocol demands case insensitive lookups. type : \"s3\" bucket : the name of the S3 bucket prefix : a path prefix to put in front of all keys (eg: /windows ) region : the AWS region where the bucket is located. Default regions can be supplied as strings, i.e. \"us-east-1\". In order to use a custom region for an S3 compatible service such as Ceph or minio, specify a tuple: [\"custom-region-name\", \"http://minio-address/\"] . access_key : the AWS access key to use secret_key : the AWS secret key to use GCS Bucket This source connects to a GCS bucket and looks for symbols there. It behaves similarly to s3 but uses different credentials: type : \"gcs\" bucket : the name of the GCS bucket prefix : a path prefix to put in front of all keys (eg: /windows ) private_key : the GCS private key (base64 encoded and with optional PEM envelope) client_email : the GCS client email for authentication Sentry This points Symbolicator at a Sentry installation to fetch customer supplied symbols from there. Sentry applies proper configuration automatically.","title":"Overview"},{"location":"api/#api","text":"Symbolicator exposes a HTTP API to allow symbolication of raw native stack traces and minidumps. All information necessary for symbolication needs to be part of the request, such as external buckets and their auth tokens or full stack traces. There are the following endpoints: POST /symbolicate : Symbolicate raw native stacktrace POST /minidump : Symbolicate a minidump and extract information POST /applecrashreport : Symbolicate an Apple Crash Report GET /requests/:id : Status update on running symbolication jobs GET /healthcheck : System status and health monitoring","title":"API"},{"location":"api/#sources","text":"For Symbolicator to operate correctly, it needs to be pointed to at least one source. It supports various different backends for where it looks for symbols. There are two modes for Symbolicator with regards to how it looks for symbols. One is the preconfigured mode where the sources key is configured right in the config file. The second is one where the sources are defined with the HTTP request to the symbolication API. If you want to use Symbolicator as a symstore compatible proxy you need to preconfigure the sources. Example configuration: [ { \"id\" : \"my-bucket-linux\" , \"type\" : \"s3\" , \"bucket\" : \"my-project-my-bucket\" , \"region\" : \"us-east-1\" , \"prefix\" : \"/linux\" , \"access_key\" : \"AMVSAVWEXRIRJPOMCKWN\" , \"secret_key\" : \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\" , \"filters\" : { \"filetypes\" : [ \"elf_debug\" , \"elf_code\" ] }, \"layout\" : { \"type\" : \"native\" , \"casing\" : \"lowercase\" } }, { \"id\" : \"my-bucket-windows\" , \"type\" : \"s3\" , \"bucket\" : \"my-project-my-bucket\" , \"region\" : \"us-east-1\" , \"prefix\" : \"/windows\" , \"access_key\" : \"AMVSAVWEXRIRJPOMCKWN\" , \"secret_key\" : \"Lqnc45YWr9y7qftCI+vST/1ZPmmw1H6SkbIf2v/8\" , \"filters\" : { \"filetypes\" : [ \"pe\" , \"pdb\" ] }, \"layout\" : { \"type\" : \"native\" , \"casing\" : \"lowercase\" } }, { \"id\" : \"microsoft\" , \"type\" : \"http\" , \"filters\" : { \"filetypes\" : [ \"pe\" , \"pdb\" ] }, \"url\" : \"https://msdl.microsoft.com/download/symbols/\" } ] Sources are ordered by priority. Each source needs at least two keys: id : the ID of the source. This can be freely chosen and is used to identify cache files in the cache folder type : defines the type of the source ( http , s3 , gcs or sentry ) These are common parameters that work on most symbol sources (except sentry ): filters : a set of filters to reduce the number of unnecessary hits on a symbol server. This configuration key is an object with two keys: filetypes : a list of file types to restrict the server to. Possible values: pe , pdb , mach_debug , mach_code , elf_debug , elf_code , breakpad ) path_patterns : a list of glob matches that need to be matched on the image name. If the debug image has no name it will never match here. layout : configures the file system layout of the sources. This configuration key is an object with two keys: type : defines the general layout of the directory. Possible values are native , symstore , symstore_index2 , ssqp , and unified . native uses the file type's native format. symstore and ssqp both use the Microsoft Symbol Server format but control the case conventions. symstore uses the conventional casing rules for signatures and filenames, ssqp uses the Microsoft SSQP casing rules instead. Additionally symstore_index2 works like symstore but uses the \"Two tier\" (index2.txt) layout where the first two characters of the filename are used as a toplevel extra folder. unified is the unified lookup format that symbolicator recommends. casing : enforces a casing style. The default is not to touch the casing and forward it unchanged. If the backend does not support a case insensitive backend (eg: S3) then it's recommended to set this to lowercase to enforce changing all to lowercase. Possible values: default , lowercase , uppercase .","title":"Sources"},{"location":"api/#http-source","text":"The HTTP source lets one fetch symbols from a Microsoft Symbol Server or similar systems. There is some flexibility to how it operates. type : \"http\" url : This defines the URL where symbolicator should be fetching from. For instance this can be https://msdl.microsoft.com/download/symbols/ to point it to the official microsoft symbol server. headers : an optional dictionary of headers that should be sent with the HTTP requests. This can be used for instance to configure HTTP basic auth configuration.","title":"HTTP source"},{"location":"api/#amazon-s3-bucket","text":"This source connects straight to an S3 bucket and looks for symbols there. It's recommended for this to be configured with explicit lowercase casing to avoid issues as the SSQP protocol demands case insensitive lookups. type : \"s3\" bucket : the name of the S3 bucket prefix : a path prefix to put in front of all keys (eg: /windows ) region : the AWS region where the bucket is located. Default regions can be supplied as strings, i.e. \"us-east-1\". In order to use a custom region for an S3 compatible service such as Ceph or minio, specify a tuple: [\"custom-region-name\", \"http://minio-address/\"] . access_key : the AWS access key to use secret_key : the AWS secret key to use","title":"Amazon S3 Bucket"},{"location":"api/#gcs-bucket","text":"This source connects to a GCS bucket and looks for symbols there. It behaves similarly to s3 but uses different credentials: type : \"gcs\" bucket : the name of the GCS bucket prefix : a path prefix to put in front of all keys (eg: /windows ) private_key : the GCS private key (base64 encoded and with optional PEM envelope) client_email : the GCS client email for authentication","title":"GCS Bucket"},{"location":"api/#sentry","text":"This points Symbolicator at a Sentry installation to fetch customer supplied symbols from there. Sentry applies proper configuration automatically.","title":"Sentry"},{"location":"api/applecrashreport/","text":"Apple Crash Report POST /applecrashreport?timeout=5&scope=123 HTTP / 1.1 Content-Type : multipart/form-data; boundary=xxx --xxx Content-Disposition: form-data; name=\"apple_crash_report\" [text file contents] --xxx Content-Disposition: form-data; name=\"sources\" Content-Type: application/json [ { \"id\": \"<uuid>\", \"type\": \"http\", ... // see \"Sources\" }, ... ] --xxx-- Query Parameters timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other Request Body A multipart form data body containing the minidump, as well as the external sources to pull symbols from. sources : A list of descriptors for internal or external symbol sources. See Sources . upload_file_minidump : The minidump file to be analyzed. Response See Symbolication Response .","title":"POST /applecrashreport"},{"location":"api/applecrashreport/#apple-crash-report","text":"POST /applecrashreport?timeout=5&scope=123 HTTP / 1.1 Content-Type : multipart/form-data; boundary=xxx --xxx Content-Disposition: form-data; name=\"apple_crash_report\" [text file contents] --xxx Content-Disposition: form-data; name=\"sources\" Content-Type: application/json [ { \"id\": \"<uuid>\", \"type\": \"http\", ... // see \"Sources\" }, ... ] --xxx--","title":"Apple Crash Report"},{"location":"api/applecrashreport/#query-parameters","text":"timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other","title":"Query Parameters"},{"location":"api/applecrashreport/#request-body","text":"A multipart form data body containing the minidump, as well as the external sources to pull symbols from. sources : A list of descriptors for internal or external symbol sources. See Sources . upload_file_minidump : The minidump file to be analyzed.","title":"Request Body"},{"location":"api/applecrashreport/#response","text":"See Symbolication Response .","title":"Response"},{"location":"api/minidump/","text":"Minidump Request POST /minidump?timeout=5&scope=123 HTTP / 1.1 Content-Type : multipart/form-data; boundary=xxx --xxx Content-Disposition: form-data; name=\"upload_file_minidump\" [binary blob] --xxx Content-Disposition: form-data; name=\"sources\" [ { \"id\": \"<uuid>\", \"type\": \"http\", ... // see \"Sources\" }, ... ] --xxx-- Query Parameters timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other Request Body A multipart form data body containing the minidump, as well as the external sources to pull symbols from. sources : A list of descriptors for internal or external symbol sources. See Sources . upload_file_minidump : The minidump file to be analyzed. Response See Symbolication Response .","title":"POST /minidump"},{"location":"api/minidump/#minidump-request","text":"POST /minidump?timeout=5&scope=123 HTTP / 1.1 Content-Type : multipart/form-data; boundary=xxx --xxx Content-Disposition: form-data; name=\"upload_file_minidump\" [binary blob] --xxx Content-Disposition: form-data; name=\"sources\" [ { \"id\": \"<uuid>\", \"type\": \"http\", ... // see \"Sources\" }, ... ] --xxx--","title":"Minidump Request"},{"location":"api/minidump/#query-parameters","text":"timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other","title":"Query Parameters"},{"location":"api/minidump/#request-body","text":"A multipart form data body containing the minidump, as well as the external sources to pull symbols from. sources : A list of descriptors for internal or external symbol sources. See Sources . upload_file_minidump : The minidump file to be analyzed.","title":"Request Body"},{"location":"api/minidump/#response","text":"See Symbolication Response .","title":"Response"},{"location":"api/proxy/","text":"Symbol Server Proxy If the symstore proxy is enabled, Symbolicator also acts as a symbol proxy. This means that all configured sources are probed for symbol queries below the /symbols prefix. The path following this prefix needs to be a valid SSQP query . Example: $ curl -IL http://localhost:3021/symbols/wkernel32.pdb/ff9f9f7841db88f0cdeda9e1e9bff3b51/wkernel32.pdb HTTP/1.1 200 OK content-length: 846848 content-type: application/octet-stream date: Fri, 19 Apr 2019 22 :47:54 GMT When fetching ELF or MachO symbols the filename can be largely omitted (non extension can be substituted with an underscore) when a configured backend uses the \"native\" directory format. In simple terms this means that /symbols/_/elf-buildid-180a373d6afbabf0eb1f09be1bc45bd796a71085/_ is a valid query for an ELF executable and /symbols/_.debug/elf-buildid-sym-180a373d6afbabf0eb1f09be1bc45bd796a71085/_.debug is a valid query for an ELF debug symbol.","title":"Symbol Server Proxy"},{"location":"api/proxy/#symbol-server-proxy","text":"If the symstore proxy is enabled, Symbolicator also acts as a symbol proxy. This means that all configured sources are probed for symbol queries below the /symbols prefix. The path following this prefix needs to be a valid SSQP query . Example: $ curl -IL http://localhost:3021/symbols/wkernel32.pdb/ff9f9f7841db88f0cdeda9e1e9bff3b51/wkernel32.pdb HTTP/1.1 200 OK content-length: 846848 content-type: application/octet-stream date: Fri, 19 Apr 2019 22 :47:54 GMT When fetching ELF or MachO symbols the filename can be largely omitted (non extension can be substituted with an underscore) when a configured backend uses the \"native\" directory format. In simple terms this means that /symbols/_/elf-buildid-180a373d6afbabf0eb1f09be1bc45bd796a71085/_ is a valid query for an ELF executable and /symbols/_.debug/elf-buildid-sym-180a373d6afbabf0eb1f09be1bc45bd796a71085/_.debug is a valid query for an ELF debug symbol.","title":"Symbol Server Proxy"},{"location":"api/response/","text":"Symbolication Response The response to a symbolication request is a JSON object which contains different data depending on the status of the symbolication job: pending : Symbolication has not finished yet; try again later. This is only returned after the timeout has expired, if one was specified. complete : The symbolication request has been processed and results are ready. This status is only reported once, after which the job is cleaned up. error : Something went wrong during symbolication, and details are in the payload. Success Response Symbol server responds with 200 OK and the response payload listed below if symbolication succeeds within a configured timeframe (around 20 seconds): { \"status\" : \"complete\" , // Symbolicated stack traces \"stacktraces\" : [ { \"frames\" : [ { // Symbolication meta data \"status\" : \"symbolicated\" , \"original_index\" : 0 , // Frame information \"instruction_addr\" : \"0xfeedbeef\" , // actual address of the frame \"addr_mode\" : \"abs\" , // address mode \"sym_addr\" : \"0xfeed0000\" , // start address of the function \"package\" : \"/path/to/module.so\" , // path to the module's code file \"symbol\" : \"__1cGmemset6FpviI_0_\" , // original mangled function name \"function\" : \"memset\" , // demangled short version of symbol \"lang\" : \"cpp\" , \"abs_path\" : \"/path/to/src/file.c\" , // normalized absolute path \"filename\" : \"../src/file.c\" , // path relative to compilation dir \"lineno\" : 22 , }, ... ], \"registers\" : { ... } } ], // Modules completed with information read from object files \"modules\" : [ { \"status\" : \"found\" , ... } ], // Additional information read from crash report \"arch\" : \"x86_64\" , \"signal\" : 11 , \"os\" : { \"name\" : \"Windows NT\" , \"version\" : \"8.1.2700\" } } The symbolicated frames are returned in the same order as provided in the request. Additional properties passed in the request are discarded. Errors that occurred during symbolication, such as missing symbol files or unresolvable addresses within symbols are reported as values for status in both modules and frames. Note on Addresses Addresses ( instruction_addr and sym_addr ) can come in two versions. They can be absolute or relative. Symbolicator will always try to make addresses absolute but in some cases this cannot be done. For instance WASM modules do not have absolute addresses in which case the addresses stay relative. This is identified by the addr_mode property. When it's set to \"abs\" it means the addresses are absolute, when \"rel:X\" it's relative to module index X . Backoff Response If symbolication takes longer than the threshold timeout , the server instead responds with a backoff response. It will then continue to fetch symbols and symbolication. The response indicates the estimated time for symbol retrieval, after which the symbolication request can be expected to succeed: { \"status\" : \"pending\" , \"request_id\" : \"deadbeef\" , \"retry_after\" : 300 // 5 minutes } The symbolication server must not send a backoff response if no timeout was sent by the client. Note that the retry_after value is just an estimation and does not give any guarantee. The request may be repeated at any time: GET /requests/deadbeef?timeout=123 Invalid Request Response If the user provided a non-existent request ID, the server responds with 404 Not Found . Requests should always be treated transient as they might disappear during a deploy. Clients must expect that 404 is returned even for valid request IDs and then re-schedule symbolication On a related note, state on the server is generally ephemeral.","title":"Symbolication Response"},{"location":"api/response/#symbolication-response","text":"The response to a symbolication request is a JSON object which contains different data depending on the status of the symbolication job: pending : Symbolication has not finished yet; try again later. This is only returned after the timeout has expired, if one was specified. complete : The symbolication request has been processed and results are ready. This status is only reported once, after which the job is cleaned up. error : Something went wrong during symbolication, and details are in the payload.","title":"Symbolication Response"},{"location":"api/response/#success-response","text":"Symbol server responds with 200 OK and the response payload listed below if symbolication succeeds within a configured timeframe (around 20 seconds): { \"status\" : \"complete\" , // Symbolicated stack traces \"stacktraces\" : [ { \"frames\" : [ { // Symbolication meta data \"status\" : \"symbolicated\" , \"original_index\" : 0 , // Frame information \"instruction_addr\" : \"0xfeedbeef\" , // actual address of the frame \"addr_mode\" : \"abs\" , // address mode \"sym_addr\" : \"0xfeed0000\" , // start address of the function \"package\" : \"/path/to/module.so\" , // path to the module's code file \"symbol\" : \"__1cGmemset6FpviI_0_\" , // original mangled function name \"function\" : \"memset\" , // demangled short version of symbol \"lang\" : \"cpp\" , \"abs_path\" : \"/path/to/src/file.c\" , // normalized absolute path \"filename\" : \"../src/file.c\" , // path relative to compilation dir \"lineno\" : 22 , }, ... ], \"registers\" : { ... } } ], // Modules completed with information read from object files \"modules\" : [ { \"status\" : \"found\" , ... } ], // Additional information read from crash report \"arch\" : \"x86_64\" , \"signal\" : 11 , \"os\" : { \"name\" : \"Windows NT\" , \"version\" : \"8.1.2700\" } } The symbolicated frames are returned in the same order as provided in the request. Additional properties passed in the request are discarded. Errors that occurred during symbolication, such as missing symbol files or unresolvable addresses within symbols are reported as values for status in both modules and frames.","title":"Success Response"},{"location":"api/response/#note-on-addresses","text":"Addresses ( instruction_addr and sym_addr ) can come in two versions. They can be absolute or relative. Symbolicator will always try to make addresses absolute but in some cases this cannot be done. For instance WASM modules do not have absolute addresses in which case the addresses stay relative. This is identified by the addr_mode property. When it's set to \"abs\" it means the addresses are absolute, when \"rel:X\" it's relative to module index X .","title":"Note on Addresses"},{"location":"api/response/#backoff-response","text":"If symbolication takes longer than the threshold timeout , the server instead responds with a backoff response. It will then continue to fetch symbols and symbolication. The response indicates the estimated time for symbol retrieval, after which the symbolication request can be expected to succeed: { \"status\" : \"pending\" , \"request_id\" : \"deadbeef\" , \"retry_after\" : 300 // 5 minutes } The symbolication server must not send a backoff response if no timeout was sent by the client. Note that the retry_after value is just an estimation and does not give any guarantee. The request may be repeated at any time: GET /requests/deadbeef?timeout=123","title":"Backoff Response"},{"location":"api/response/#invalid-request-response","text":"If the user provided a non-existent request ID, the server responds with 404 Not Found . Requests should always be treated transient as they might disappear during a deploy. Clients must expect that 404 is returned even for valid request IDs and then re-schedule symbolication On a related note, state on the server is generally ephemeral.","title":"Invalid Request Response"},{"location":"api/symbolication/","text":"Symbolication Request POST /symbolicate?timeout=123&scope=123 HTTP / 1.1 Content-Type : application/json { \"signal\" : 11 , \"sources\" : [ { \"id\" : \"<uuid>\" , \"type\" : \"http\" , ... }, ... ], \"threads\" : [ { \"frames\" : [ { \"instruction_addr\" : \"0xfeedbeef\" , \"addr_mode\" : \"rel:0\" }, ... ], \"registers\" : { \"rip\" : \"0xfeedbeef\" , \"rsp\" : \"0xfeedface\" } } ], \"modules\" : [ { \"type\" : \"macho\" , \"debug_id\" : \"some-debug-id\" , \"code_id\" : \"some-debug-id\" , \"debug_file\" : \"/path/to/image.so\" , \"image_addr\" : \"0xfeedbeef\" , \"image_size\" : \"0xbeef\" }, ... ] } Query Parameters timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other Request Body A JSON payload describing the stack traces and code modules for symbolication, as well as external sources to pull symbols from: sources : A list of descriptors for internal or external symbol sources. See Sources . modules : A list of code modules (aka debug images) that were loaded into the process. All attributes other than type , image_addr and image_size are required. The Symbolicator may optimize lookups based on the type if present. Valid types are macho , pe , elf . Invalid types are silently ignored. The Symbolicator still works if the type is invalid, but less efficiently. However, a schematically valid but wrong type is fatal for finding symbols. threads : A list of process threads to symbolicate. registers : Optional register values aiding symbolication heuristics. For example, register values may be used to perform correction heuristics on the instruction address of the top frame. frames : A list of frames with addresses. Arbitrary additional properties may be passed with frames, but are discarded. The addr_mode property defines the beahvior of instruction_addr . Response See Symbolication Response .","title":"POST /symbolicate"},{"location":"api/symbolication/#symbolication-request","text":"POST /symbolicate?timeout=123&scope=123 HTTP / 1.1 Content-Type : application/json { \"signal\" : 11 , \"sources\" : [ { \"id\" : \"<uuid>\" , \"type\" : \"http\" , ... }, ... ], \"threads\" : [ { \"frames\" : [ { \"instruction_addr\" : \"0xfeedbeef\" , \"addr_mode\" : \"rel:0\" }, ... ], \"registers\" : { \"rip\" : \"0xfeedbeef\" , \"rsp\" : \"0xfeedface\" } } ], \"modules\" : [ { \"type\" : \"macho\" , \"debug_id\" : \"some-debug-id\" , \"code_id\" : \"some-debug-id\" , \"debug_file\" : \"/path/to/image.so\" , \"image_addr\" : \"0xfeedbeef\" , \"image_size\" : \"0xbeef\" }, ... ] }","title":"Symbolication Request"},{"location":"api/symbolication/#query-parameters","text":"timeout : If given, a response status of pending might be sent by the server. scope : An optional scope which will be used to isolate cached files from each other","title":"Query Parameters"},{"location":"api/symbolication/#request-body","text":"A JSON payload describing the stack traces and code modules for symbolication, as well as external sources to pull symbols from: sources : A list of descriptors for internal or external symbol sources. See Sources . modules : A list of code modules (aka debug images) that were loaded into the process. All attributes other than type , image_addr and image_size are required. The Symbolicator may optimize lookups based on the type if present. Valid types are macho , pe , elf . Invalid types are silently ignored. The Symbolicator still works if the type is invalid, but less efficiently. However, a schematically valid but wrong type is fatal for finding symbols. threads : A list of process threads to symbolicate. registers : Optional register values aiding symbolication heuristics. For example, register values may be used to perform correction heuristics on the instruction address of the top frame. frames : A list of frames with addresses. Arbitrary additional properties may be passed with frames, but are discarded. The addr_mode property defines the beahvior of instruction_addr .","title":"Request Body"},{"location":"api/symbolication/#response","text":"See Symbolication Response .","title":"Response"}]}